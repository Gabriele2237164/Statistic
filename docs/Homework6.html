<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Homework 5 – Research and Analytical Task</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>     
  <script>
    MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f5f5f7; color:#1d1d1f; margin:0; padding:0; }
    header { text-align:center; padding:2rem 1rem; }
    h1 { margin:0; font-size:1.8rem; }
    .wrap { max-width:1000px; margin:1rem auto; padding:1rem; }
    .card { background:#fff; padding:1.5rem; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.08); margin-bottom:1.5rem; }
    h2, h3 { color:#1d1d1f; margin-top:1rem; }
    ul { padding-left:1.25rem; }
    li { margin-bottom:0.4rem; }
    p { line-height:1.6; }
    table { width:100%; border-collapse:collapse; margin-top:0.75rem;}
    th, td { padding:6px 8px; border-bottom:1px solid #eee; font-size:0.95rem; text-align:left; }
    th { background:#f8f8fc; font-weight:600; }
    .info-box { background:#eef2ff; padding:1rem; border-left:4px solid #6366f1; border-radius:8px; margin:1.5rem 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#f0f0f0; padding:2px 4px; border-radius:4px; }
    .formula { margin:0.5rem 0 0.75rem 1.5rem; font-size:1rem; }
    button { margin:0.4rem 0.2rem; padding:0.5rem 1rem; border:none; background:#0b66ff; color:#fff; border-radius:8px; cursor:pointer; font-weight:500; transition:background .25s; }
    button:hover { background:#005bb5; }
    pre { background:#f8f8fa; padding:0.8rem; border-radius:8px; white-space:pre-wrap; overflow-x:auto; max-height:300px; }
    canvas { width:100%; height:220px; margin-top:0.5rem; }
    .back-button {display: block;text-align: center;width: fit-content;margin: 2rem auto 0;padding: 0.75rem 1.5rem;background-color: #6e6e73;color: #fff;text-decoration: none;font-weight: 500;font-size: 1rem;border-radius: 12px;box-shadow: 0 4px 12px rgba(0,0,0,0.15);transition: all 0.25s ease;}
    .back-button:hover {background-color: #5e5e63;box-shadow: 0 6px 16px rgba(0,0,0,0.2);transform: translateY(-2px);}
    footer { text-align:center; margin:2rem 0; font-size:0.9rem; color:#86868b; }
  </style>
</head>
<body>
  <header>
    <h1>Homework 5 – Research and Analytical Task</h1>
  </header>

  <div class="wrap">

    <div class="card">
      <h2>Analytical Task – Derivation and Online Implementation</h2>

      <h3>1. Derivation of Recurrence Relationships</h3>
      <p><b>Arithmetic Mean</b></p>
      <div class="formula">
        The arithmetic mean of $n$ observations is $\bar{x}_n = \frac{1}{n}\sum_{i=1}^n x_i$.  
        When a new observation $x_{n+1}$ arrives:
        $$\bar{x}_{n+1} = \frac{n\bar{x}_n + x_{n+1}}{n+1} = \bar{x}_n + \frac{x_{n+1}-\bar{x}_n}{n+1}.$$
        This provides a simple, memory-efficient incremental update for the mean.
      </div>

      <p><b>Variance (Welford’s Recurrence)</b></p>
      <div class="formula">
        Let $M_{2,n} = \sum_{i=1}^n (x_i - \bar{x}_n)^2$.  
        The recurrence relations are:
        \[
        \begin{aligned}
        \delta &= x_{n+1} - \bar{x}_n,\\
        \bar{x}_{n+1} &= \bar{x}_n + \frac{\delta}{n+1},\\
        M_{2,n+1} &= M_{2,n} + \delta (x_{n+1} - \bar{x}_{n+1}).
        \end{aligned}
        \]
        Then, the sample variance is $s^2 = \frac{M_{2,n}}{n-1}$.
      </div>
    </div>

    <div class="card">
      <h2>2. Implementation and Testing (Online Algorithms)</h2>
      <p>
        The following JavaScript implementation tests the incremental mean and Welford variance algorithms 
        compared with traditional batch computations.  
        Click <b>Run demo</b> to generate random datasets and visualize numerical behavior.
      </p>

      <button id="btnRunNormal">Run demo (normal)</button>
      <button id="btnRunOffset">Run demo (large offset)</button>
      <button id="btnClear">Clear</button>

      <h3>Mean Comparison</h3>
      <canvas id="chartMean"></canvas>

      <h3>Variance Comparison</h3>
      <canvas id="chartVar"></canvas>

      <h3>Numeric Log</h3>
      <pre id="logArea">No run yet.</pre>
    </div>

    <div class="card">
      <h2>3. Discussion – Numerical and Computational Advantages</h2>

      <div class="info-box">
        <h3>Numerical Stability</h3>
        <p>
          Online algorithms like Welford’s method greatly improve numerical stability by avoiding the subtraction
          of large, nearly equal numbers—a source of <em>catastrophic cancellation</em> in the traditional batch formula
          $s^2 = (\sum x_i^2 - n\bar{x}^2)/(n-1)$.  
          By updating the mean and variance incrementally using small differences ($\delta$ terms), the method preserves
          significant digits even when data values are large or when their magnitudes differ widely.
        </p>

        <h3>Error Propagation and Floating-Point Accuracy</h3>
        <p>
          Each update in the Welford algorithm depends only on the previous mean, variance, and the new data point.
          This local dependency means that rounding errors do not accumulate significantly over time.
          In contrast, batch methods accumulate floating-point errors across potentially millions of terms,
          leading to slow numerical drift.  
          The online approach, by minimizing the number of floating-point operations per sample, ensures long-term accuracy
          even for very large streaming datasets.
        </p>

        <h3>Catastrophic Cancellation and Overflow Prevention</h3>
        <p>
          Batch methods compute $\sum x_i^2$ and $n\bar{x}^2$ separately—both can be extremely large for datasets with large
          magnitudes, even if their difference (the variance) is small. Subtracting such large numbers leads to catastrophic cancellation
          or even overflow.  
          Welford’s recurrence avoids this by never explicitly computing squared sums; intermediate values stay within a numerically safe range.
        </p>

        <h3>Efficiency and Memory Usage</h3>
        <p>
          Online algorithms require <b>O(1)</b> time and <b>O(1)</b> memory per new observation.
          They update statistics incrementally and do not need to store the entire dataset.
          Batch algorithms, by contrast, require <b>O(n)</b> memory and must recompute sums each time,
          making them infeasible for real-time or large-scale processing.  
          This makes online algorithms particularly well-suited for applications like IoT analytics, streaming data platforms, and embedded systems.
        </p>

        <h3>Scalability and Streaming Applications</h3>
        <p>
          The incremental approach scales naturally with the data stream size.  
          In big data or distributed environments (e.g., Apache Spark, Flink), online updates can be computed locally and aggregated
          across nodes without accessing the raw data again—enabling <b>distributed incremental statistics</b> with minimal communication overhead.
        </p>

        <h3>Robustness and Limitations</h3>
        <p>
          Despite their numerical advantages, online algorithms are not immune to outliers or non-stationary data.
          A single extreme value can shift the mean or variance substantially.  
          To mitigate this, practitioners often use <b>robust online estimators</b> such as exponentially weighted moving averages (EWMA)
          or hybrid median-based statistics that down-weight new observations.
        </p>

        <h3>Summary of Advantages over Batch Methods</h3>
        <ul>
          <li>✅ Higher numerical precision and stability.</li>
          <li>✅ Constant-time, constant-memory updates.</li>
          <li>✅ Reduced risk of overflow and cancellation errors.</li>
          <li>✅ Ideal for streaming, embedded, and large-scale systems.</li>
          <li>⚠️ Sensitive to outliers and distributional drift.</li>
        </ul>

        <h3>Concluding Remarks</h3>
        <p>
          In conclusion, online algorithms provide a mathematically elegant and computationally robust alternative to classical batch processing.
          Their incremental nature aligns perfectly with modern data analysis needs, where datasets are too large or too dynamic
          to be processed in a single batch.  
          From a numerical analysis standpoint, they represent one of the most stable and scalable ways to compute fundamental descriptive statistics.
        </p>
      </div>
    </div>

  </div>

  <a class="back-button" href="../index.html">← Back</a>

  <footer>© 2025 Gabriele Paladini — All rights reserved.</footer>

  <script>
    function randnArray(n, mean=0, sd=1) {
      const out = new Array(n);
      for (let i=0; i<n; i+=2){
        const u1 = Math.random() || 1e-16;
        const u2 = Math.random();
        const r = Math.sqrt(-2*Math.log(u1));
        const z0 = r*Math.cos(2*Math.PI*u2);
        const z1 = r*Math.sin(2*Math.PI*u2);
        out[i] = mean + sd*z0;
        if (i+1<n) out[i+1] = mean + sd*z1;
      }
      return out;
    }

    function batchStats(arr){
      const n = arr.length;
      let s=0, ss=0;
      for (let x of arr){ s+=x; ss += x*x;}
      const mean = s/n;
      const varSample = n>1 ? (ss - n*mean*mean)/(n-1) : 0;
      return {n, mean, varSample};
    }

    function naiveOnline(arr){
      let n=0, s=0, ss=0;
      for (let x of arr){ n++; s+=x; ss+=x*x;}
      const mean = s/n;
      const varSample = n>1 ? (ss - n*mean*mean)/(n-1) : 0;
      return {n, mean, varSample};
    }

    function welfordStream(arr){
      let n=0, mean=0, M2=0;
      const means = [], vars = [];
      for (let x of arr){
        n++;
        const delta = x - mean;
        mean += delta / n;
        const delta2 = x - mean;
        M2 += delta * delta2;
        means.push(mean);
        vars.push(n>1 ? M2/(n-1) : 0);
      }
      return {n, mean, varSample: n>1 ? M2/(n-1) : 0, means, vars};
    }

    let meanChart = null, varChart = null;

    function createChart(ctx, labels, datasets, title){
      return new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: { responsive:true, plugins:{ title:{ display:true, text:title } }, interaction:{ mode:'index', intersect:false } }
      });
    }

    function clearUI(){
      if (meanChart) meanChart.destroy();
      if (varChart) varChart.destroy();
      document.getElementById('logArea').textContent = 'No run yet.';
    }

    function runDemo(offset=0){
      const n = 1000;
      const data = randnArray(n, offset, 1);

      const batch = batchStats(data);
      const naive = naiveOnline(data);
      const w = welfordStream(data);

      const labels = data.map((_,i)=>i+1);
      const batchMean = new Array(n).fill(batch.mean);
      const batchVar = new Array(n).fill(batch.varSample);

      const ctxMean = document.getElementById('chartMean').getContext('2d');
      const ctxVar = document.getElementById('chartVar').getContext('2d');
      if (meanChart) meanChart.destroy();
      if (varChart) varChart.destroy();

      meanChart = createChart(ctxMean, labels, [
        { label:'Batch Mean', data:batchMean, borderColor:'#222', borderWidth:1, pointRadius:0 },
        { label:'Welford Mean', data:w.means, borderColor:'#0b66ff', borderWidth:2, pointRadius:0 }
      ], 'Mean Comparison');

      varChart = createChart(ctxVar, labels, [
        { label:'Batch Var', data:batchVar, borderColor:'#222', borderWidth:1, pointRadius:0 },
        { label:'Welford Var', data:w.vars, borderColor:'#6366f1', borderWidth:2, pointRadius:0 }
      ], 'Variance Comparison');

      const log = [
        `Dataset size: ${n}, offset=${offset}`,
        '',
        `Batch mean = ${batch.mean}`,
        `Welford mean = ${w.mean}`,
        `Naive mean = ${naive.mean}`,
        '',
        `Batch variance = ${batch.varSample}`,
        `Welford variance = ${w.varSample}`,
        `Naive variance = ${naive.varSample}`,
        '',
        `Welford mean error = ${(w.mean - batch.mean).toExponential()}`,
        `Naive mean error = ${(naive.mean - batch.mean).toExponential()}`,
        `Welford var error = ${(w.varSample - batch.varSample).toExponential()}`,
        `Naive var error = ${(naive.varSample - batch.varSample).toExponential()}`,
      ];
      document.getElementById('logArea').textContent = log.join('\n');
    }

    document.getElementById('btnRunNormal').addEventListener('click', ()=>runDemo(0));
    document.getElementById('btnRunOffset').addEventListener('click', ()=>runDemo(1e9));
    document.getElementById('btnClear').addEventListener('click', clearUI);
  </script>
</body>
</html>
