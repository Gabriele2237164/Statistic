<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Counting Process Simulation — Poisson Approximation</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>

  <script>
    window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
           background:#f5f5f7; color:#1d1d1f; margin:0; padding:0; }
    header { text-align:center; padding:2rem 1rem; }
    h1 { margin:0; font-size:1.6rem; }
    .wrap { max-width:1100px; margin:1rem auto; padding:1rem; }
    .card { background:#fff; padding:1.2rem 1.4rem; border-radius:12px;
           box-shadow:0 4px 12px rgba(0,0,0,0.06); margin-bottom:1rem; }
    label { display:inline-block; margin-right:0.8rem; }
    input[type="number"] { width:80px; padding:0.25rem; margin-left:0.4rem; border-radius:6px; border:1px solid #ddd; }
    button { margin-left:0.4rem; padding:0.5rem 0.9rem; border-radius:8px; border:none; background:#0b66ff; color:#fff; cursor:pointer; }
    .row { display:flex; gap:1rem; flex-wrap:wrap; }
    .col { flex:1; min-width:320px; }
    canvas { display:block; width:100%; height:320px; }
    .info { font-size:0.95rem; color:#222; }
    .small { font-size:0.9rem; color:#555; }
    table.metrics { width:100%; border-collapse:collapse; margin-top:0.75rem; }
    table.metrics td { padding:6px 8px; border-bottom:1px solid #eee; }
    .back-button {display: block;text-align: center;width: fit-content;margin: 1.5rem auto 0;padding: 0.65rem 1.2rem;background-color: #6e6e73;color: #fff;text-decoration: none;font-weight: 500;font-size: 0.95rem;border-radius: 10px;box-shadow: 0 4px 12px rgba(0,0,0,0.12);transition: all 0.2s ease;}
    .back-button:hover {transform: translateY(-2px); background-color:#5e5e63;}
    footer { text-align:center; margin:2rem 0; font-size:0.9rem; color:#86868b; }
    .math-block { background:#f8fafc; padding:0.6rem; border-radius:8px; margin-top:0.6rem; border:1px solid #eef2f8; }
  </style>
</head>
<body>
  <header>
    <h1>Homework10: Simulating a Counting Process (Poisson approximation)</h1>
  </header>

  <div class="wrap">
    <div class="card">
      <h2>Parameters & Controls</h2>
      <div class="info">
        <label>Rate \( \lambda \): <input id="inLambda" type="number" step="0.1" value="5" min="0"></label>
        <label>Total time \(T\): <input id="inT" type="number" step="0.1" value="1" min="0.01"></label>
        <label>Subintervals \(n\): <input id="inN" type="number" value="5000" min="1"></label>
        <label>Simulations \(m\): <input id="inM" type="number" value="1000" min="1"></label>
        <label>Show at most trajectories: <input id="inShow" type="number" value="50" min="1"></label>
        <button id="btnRun">Run Simulation</button>
      </div>

      <div class="small math-block">
        <strong>Approximation:</strong>
        Divide interval $[0,T]$ into $n$ equal subintervals. In each subinterval generate an event with probability $p=\lambda/n$.
        The number of events in $[0,T]$ is $N_T \sim \mathrm{Binomial}(n,\lambda/n)$, which converges to $\mathrm{Poisson}(\lambda)$ as $n\to\infty$.
      </div>
    </div>

    <div class="row">
      <div class="col card">
        <h3>Sample trajectories (counting process $N(t)$)</h3>
        <canvas id="chartTraj"></canvas>
        <div class="small">Each trajectory is a nondecreasing step function showing cumulative events over time.</div>
      </div>

      <div class="col card">
        <h3>Histogram of final counts $N(T)$</h3>
        <canvas id="chartHist"></canvas>
        <table class="metrics">
          <tr><td>Empirical mean of $N(T)$</td><td id="empMean">—</td></tr>
          <tr><td>Empirical variance of $N(T)$</td><td id="empVar">—</td></tr>
          <tr><td>Theoretical mean = variance</td><td id="theoVal">—</td></tr>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>Analysis & Interpretation</h2>
      <p class="info">
        The described approximation produces (in the limit $n\to\infty$) a <strong>homogeneous Poisson process</strong> with rate $\lambda$ on $[0,T]$.
        Key properties:
      </p>
      <ul class="info">
        <li><strong>Independent increments:</strong> numbers of events in disjoint time intervals are independent.</li>
        <li><strong>Stationary increments:</strong> distribution of events in an interval depends only on interval length, not location.</li>
        <li><strong>Poisson counts:</strong> $N(t+s)-N(s)\sim\operatorname{Poisson}(\lambda t)$.</li>
        <li><strong>Inter-arrival times:</strong> are i.i.d. exponential with parameter $\lambda$ (memoryless).</li>
      </ul>

      <p class="info">
        The rate parameter $\lambda$ means the expected number of events per unit time: $E[N(T)]=\lambda T$.
        The discrete Bernoulli approximation uses $p=\lambda/n$ per small interval; for large $n$ the binomial distribution $\mathrm{Bin}(n,\lambda/n)$ converges to $\mathrm{Poisson}(\lambda)$.
      </p>

      <div class="math-block">
        Short formulas:
        <div class="small">
          $P(N(T)=k)=\dfrac{(\lambda T)^k e^{-\lambda T}}{k!}, \quad E[N(T)]=\lambda T, \; \mathrm{Var}(N(T))=\lambda T.$
        </div>
      </div>
    </div>

    <a class="back-button" href="../index.html">← Back</a>

    <footer>
      © 2025 Gabriele Paladini — All rights reserved.
    </footer>
  </div>

  <script>
    function poissonPMF(k, lambda) {
      if (k < 0 || Math.floor(k) !== k) return 0;
      let res = Math.exp(-lambda);
      let numer = 1;
      for (let i = 1; i <= k; i++) numer *= lambda / i;
      return res * numer * Math.exp(lambda) * Math.exp(-lambda) * Math.exp(-0);
    }

    function poissonPMF_clean(k, lambda) {
      if (k < 0 || Math.floor(k) !== k) return 0;
      let logP = -lambda;
      for (let i = 1; i <= k; i++) logP += Math.log(lambda) - Math.log(i);
      return Math.exp(logP);
    }

    function simulateCounting(lambda, T, n, m) {
      const p = lambda / n;
      const dt = T / n;
      const timePoints = new Array(n+1);
      for (let i=0;i<=n;i++) timePoints[i] = i*dt;
      const paths = new Array(m);
      const finalCounts = new Array(m);
      for (let run=0; run<m; run++) {
        const counts = new Array(n+1);
        let cum = 0;
        counts[0] = 0;
        for (let i=1;i<=n;i++){
          if (Math.random() < p) cum++;
          counts[i] = cum;
        }
        paths[run] = counts;
        finalCounts[run] = cum;
      }
      return {timePoints, paths, finalCounts};
    }

    let chartTraj = null;
    let chartHist = null;

    function buildTrajectoryDatasets(timePoints, paths, showMax) {
      const datasets = [];
      const palette = [
        'rgba(0,112,243,0.9)','rgba(0,112,243,0.7)','rgba(0,112,243,0.5)',
        'rgba(255,99,132,0.9)','rgba(255,159,64,0.9)','rgba(75,192,192,0.9)'
      ];
      const step = Math.max(1, Math.floor(paths.length / showMax));
      let colorIdx = 0;
      for (let i=0;i<paths.length;i+=step){
        const y = paths[i];
        datasets.push({
          label: `Run ${i+1}`,
          data: y.map((v, idx)=>({x: timePoints[idx], y: v})),
          borderColor: palette[colorIdx % palette.length],
          borderWidth: 1,
          pointRadius: 0,
          tension: 0,
          fill: false
        });
        colorIdx++;
        if (datasets.length >= showMax) break;
      }
      return datasets;
    }

    function buildHistogram(finalCounts) {
      const min = Math.min(...finalCounts);
      const max = Math.max(...finalCounts);
      const labels = [];
      const counts = [];
      for (let k = min; k <= max; k++){
        labels.push(k);
        counts.push(0);
      }
      finalCounts.forEach(v => counts[v - min]++);
      return {labels, counts, min, max};
    }

    function renderCharts(sim, lambda, T, m, showMax) {
      const tp = sim.timePoints;
      const paths = sim.paths;
      const finals = sim.finalCounts;

      const ctx1 = document.getElementById('chartTraj').getContext('2d');
      if (chartTraj) chartTraj.destroy();
      const trajDatasets = buildTrajectoryDatasets(tp, paths, showMax);
      chartTraj = new Chart(ctx1, {
        type: 'line',
        data: { datasets: trajDatasets },
        options: {
          parsing: false,
          normalized: true,
          plugins: {
            title: { display: true, text: `Counting process sample trajectories (showing up to ${trajDatasets.length} runs)` },
            legend: { display: false }
          },
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: 'time' },
            },
            y: {
              beginAtZero: true,
              title: { display: true, text: 'N(t) - cumulative count' },
              ticks: { precision: 0 }
            }
          }
        }
      });

      const hist = buildHistogram(finals);
      const ctx2 = document.getElementById('chartHist').getContext('2d');
      if (chartHist) chartHist.destroy();

      const extend = Math.max(5, Math.ceil(lambda*T*0.5));
      const kMin = Math.max(0, hist.min);
      const kMax = Math.max(hist.max, Math.ceil(lambda*T + extend));
      const kRange = [];
      for (let k = kMin; k <= kMax; k++) kRange.push(k);

      const pmf = kRange.map(k => poissonPMF_clean(k, lambda*T));
      const pmfScaled = pmf.map(p=>p * m);

      const empCounts = kRange.map(k => {
        if (k >= hist.min && k <= hist.max) return hist.counts[k - hist.min];
        return 0;
      });

      chartHist = new Chart(ctx2, {
        type: 'bar',
        data: {
          labels: kRange,
          datasets: [
            { type: 'bar', label: 'Empirical counts', data: empCounts, backgroundColor: 'rgba(255,99,132,0.7)', borderWidth:1 },
            { type: 'line', label: 'Poisson theoretical (scaled)', data: pmfScaled, borderColor: 'rgba(0,0,0,0.85)', borderWidth:2, fill:false, pointRadius:3, tension:0.2 }
          ]
        },
        options: {
          plugins: { title: { display: true, text: `Distribution of N(T) across ${m} runs (T=${T}, λ=${lambda})` } },
          scales: {
            x: { title: { display: true, text: 'k = N(T)' } },
            y: { title: { display: true, text: 'Counts (empirical) / scaled PMF' } }
          }
        }
      });

      const mean = finals.reduce((a,b)=>a+b,0) / finals.length;
      const varEmp = finals.reduce((s,v)=>s + Math.pow(v-mean,2), 0) / (finals.length - 1 || 1);
      document.getElementById('empMean').textContent = mean.toFixed(4);
      document.getElementById('empVar').textContent = varEmp.toFixed(4);
      document.getElementById('theoVal').textContent = (lambda*T).toFixed(4) + " (mean = var)";
    }

    document.getElementById('btnRun').addEventListener('click', ()=>{
      const lambda = parseFloat(document.getElementById('inLambda').value);
      const T = parseFloat(document.getElementById('inT').value);
      const n = parseInt(document.getElementById('inN').value);
      const m = parseInt(document.getElementById('inM').value);
      const showMax = parseInt(document.getElementById('inShow').value);

      if (!(lambda >= 0 && T > 0 && n >= 1 && m >= 1)) {
        alert('Please provide valid parameters.');
        return;
      }
      const sim = simulateCounting(lambda, T, n, m);
      renderCharts(sim, lambda, T, m, showMax);
    });
    
  </script>
</body>
</html>
