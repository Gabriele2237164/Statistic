<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Homework10: Wiener Process & SDE Simulation — Euler–Maruyama</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>

  <script>
    window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
           background:#f5f5f7; color:#1d1d1f; margin:0; padding:0; }
    header { text-align:center; padding:2rem 1rem; }
    h1 { margin:0; font-size:1.6rem; }
    .wrap { max-width:1100px; margin:1rem auto; padding:1rem; }
    .card { background:#fff; padding:1.2rem 1.4rem; border-radius:12px;
           box-shadow:0 4px 12px rgba(0,0,0,0.06); margin-bottom:1rem; }
    label { display:inline-block; margin-right:0.8rem; }
    input[type="number"], input[type="text"], select { width:120px; padding:0.25rem; margin-left:0.4rem; border-radius:6px; border:1px solid #ddd; }
    button { margin-left:0.4rem; padding:0.5rem 0.9rem; border-radius:8px; border:none; background:#0b66ff; color:#fff; cursor:pointer; }
    .row { display:flex; gap:1rem; flex-wrap:wrap; }
    .col { flex:1; min-width:320px; }
    canvas { display:block; width:100%; height:320px; }
    .info { font-size:0.95rem; color:#222; }
    .small { font-size:0.9rem; color:#555; }
    table.metrics { width:100%; border-collapse:collapse; margin-top:0.75rem; }
    table.metrics td { padding:6px 8px; border-bottom:1px solid #eee; }
    .back-button {display: block;text-align: center;width: fit-content;margin: 1.5rem auto 0;padding: 0.65rem 1.2rem;background-color: #6e6e73;color: #fff;text-decoration: none;font-weight: 500;font-size: 0.95rem;border-radius: 10px;box-shadow: 0 4px 12px rgba(0,0,0,0.12);transition: all 0.2s ease;}
    .back-button:hover {transform: translateY(-2px); background-color:#5e5e63;}
    footer { text-align:center; margin:2rem 0; font-size:0.9rem; color:#86868b; }
    .math-block { background:#f8fafc; padding:0.6rem; border-radius:8px; margin-top:0.6rem; border:1px solid #eef2f8; }
    .controls-grid { display:flex; gap:1rem; flex-wrap:wrap; align-items:center; }
    .note { margin-top:0.6rem; font-size:0.88rem; color:#666; }
  </style>
</head>
<body>
  <header>
    <h1>Homework10: Simulation of Wiener Process & SDE — Euler–Maruyama Method</h1>
  </header>

  <div class="wrap">
    <div class="card">
      <h2>Parameters & Controls</h2>
      <div class="info controls-grid">
        <label>Process type:
          <select id="procType">
            <option value="wiener">Wiener / Brownian motion</option>
            <option value="sde">General SDE (Euler–Maruyama)</option>
          </select>
        </label>

        <label>Total time \(T\): <input id="inT" type="number" step="0.1" value="1" min="0.001"></label>
        <label>Subintervals \(n\): <input id="inN" type="number" value="1000" min="1"></label>
        <label>Simulations \(m\): <input id="inM" type="number" value="200" min="1"></label>
        <label>Show at most: <input id="inShow" type="number" value="40" min="1"></label>
        <button id="btnRun">Run Simulation</button>
      </div>

      <div class="math-block">
        <strong>Goal:</strong>
        <div class="small">
          Simulate the Wiener process \(W_t\) using increments \(W_{t+dt}-W_t \sim \mathcal{N}(0,dt)\).
          For a general SDE
          $$dX_t = a(X_t,t)\,dt + b(X_t,t)\,dW_t,$$
          the Euler–Maruyama approximation is
          $$X_{k+1} = X_k + a(X_k,t_k)\,\Delta t + b(X_k,t_k)\,\Delta W_k,$$
          with \(\Delta W_k \sim \sqrt{\Delta t}\,N(0,1)\).
        </div>
      </div>

      <div class="card" style="margin-top:0.8rem; padding:0.9rem;">
        <h3>SDE Parameters (used only when "General SDE" is selected)</h3>
        <div class="small">
          <label>Initial value \(X_0\): <input id="inX0" type="number" step="0.1" value="0"></label>
          <label>Drift form: 
            <select id="driftForm">
              <option value="const">constant: a(x,t)=μ</option>
              <option value="linear">linear: a(x,t)=μ·x</option>
              <option value="custom">custom expression</option>
            </select>
          </label>
          <label>μ: <input id="inMu" type="number" step="0.1" value="0"></label>
          <label>Diffusion form: 
            <select id="diffForm">
              <option value="const">constant: b(x,t)=σ</option>
              <option value="linear">linear: b(x,t)=σ·x</option>
              <option value="custom">custom expression</option>
            </select>
          </label>
          <label>σ: <input id="inSigma" type="number" step="0.1" value="1"></label>
        </div>
        <div style="margin-top:0.6rem;">
          <div class="small">If you select <em>custom expression</em>, write a JavaScript expression in terms of <code>x</code> and <code>t</code>, e.g., <code>"Math.sin(t) + 0.2*x"</code>.</div>
          <input id="customDrift" type="text" style="width:100%;" placeholder='Custom drift, e.g., "0.5 - 0.1*x"'/>
          <input id="customDiff"  type="text" style="width:100%; margin-top:0.4rem;" placeholder='Custom diffusion, e.g., "0.3 + 0.1*Math.abs(x)"' />
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col card">
        <h3>Sample Trajectories</h3>
        <canvas id="chartTraj"></canvas>
        <div class="small note">Each line is one realization. For Wiener: \(W_T \sim \mathcal{N}(0,T)\).</div>
      </div>

      <div class="col card">
        <h3>Histogram of \(X(T)\) (final values)</h3>
        <canvas id="chartHist"></canvas>
        <table class="metrics">
          <tr><td>Empirical mean of \(X(T)\)</td><td id="empMean">—</td></tr>
          <tr><td>Empirical variance of \(X(T)\)</td><td id="empVar">—</td></tr>
          <tr><td>Theoretical value (if applicable)</td><td id="theoVal">—</td></tr>
        </table>
      </div>
    </div>

    <div class="card">
        <h2>Analysis & Notes</h2>
      
        <h3>1. Wiener Process \(W_t\)</h3>
        <p class="info">
          The Wiener process, also called Brownian motion, is a continuous-time stochastic process satisfying:
        </p>
      
        <ul class="info">
          <li>\(W_0 = 0\)</li>
          <li>Independent increments</li>
          <li>Gaussian increments: \(W_{t+dt} - W_t \sim \mathcal{N}(0, dt)\)</li>
          <li>Continuous (but nowhere differentiable) paths</li>
        </ul>
      
        <p class="info">
          In the simulation, increments are generated as:
        </p>
      
        <div class="math-block">
          \[
            \Delta W_k = \sqrt{\Delta t} \, Z_k,\quad Z_k \sim \mathcal{N}(0,1)
          \]
        </div>
      
        <p class="info">
          At the final time, the distribution is known analytically:
        </p>
        <div class="math-block">
          \[
            W_T \sim \mathcal{N}(0,T)
          \]
        </div>
      
        <h3>2. General SDE \(dX_t = a(X_t,t)\,dt + b(X_t,t)\,dW_t\)</h3>
        <p class="info">
          A stochastic differential equation (SDE) adds drift and diffusion to the Wiener process. In this simulator:
        </p>
      
        <ul class="info">
          <li><strong>Drift</strong> \(a(x,t)\): deterministic trend</li>
          <li><strong>Diffusion</strong> \(b(x,t)\): strength of random fluctuations</li>
        </ul>
      
        <p class="info">
          Drift and diffusion can be:
        </p>
      
        <ul class="info">
          <li>Constant: \(a(x,t)=\mu\), \(b(x,t)=\sigma\)</li>
          <li>Linear: \(a(x,t)=\mu x\), \(b(x,t)=\sigma x\)</li>
          <li>Custom: arbitrary JS expressions in <code>x</code> and <code>t</code></li>
        </ul>
      
        <h3>3. Euler–Maruyama Method</h3>
        <p class="info">
          The Euler–Maruyama scheme approximates SDE trajectories through discrete time steps:
        </p>
      
        <div class="math-block">
          \[
            X_{k+1} = X_k + a(X_k,t_k)\Delta t + b(X_k,t_k)\Delta W_k.
          \]
        </div>
      
        <p class="info">
          It is a first-order method in the mean-square sense. While simple and efficient, it may introduce bias when \(b(x,t)\) is strongly state-dependent (multiplicative noise).
        </p>
      
        <h3>4. Simulation Architecture</h3>
        <p class="info">
          The script uses the following structure:
        </p>
      
        <ul class="info">
          <li><strong>Time grid:</strong> \(t_k = k\Delta t\) with \(\Delta t = T/n\)</li>
          <li><strong>Paths:</strong> An array of length \(m\), each containing a trajectory with \(n+1\) points</li>
          <li><strong>Randomness:</strong> Gaussian numbers generated via the Box–Muller method</li>
          <li><strong>Final distribution:</strong> Histogram of \(\{X_i(T)\}\) from the \(m\) simulations</li>
        </ul>
      
        <p class="info">
          For Wiener processes, a theoretical Gaussian curve is superimposed for validation.
        </p>
      
        <h3>5. Charts & Numerical Output</h3>
        <p class="info">
          The interface includes two key visual components:
        </p>
      
        <ul class="info">
          <li><strong>Sample Trajectories:</strong> Up to <em>showMax</em> paths are plotted for readability.</li>
          <li><strong>Histogram of \(X(T)\):</strong> Displays the empirical distribution of final values.</li>
        </ul>
      
        <p class="info">
          Additionally, the following statistics are computed:
        </p>
      
        <ul class="info">
          <li><strong>Empirical Mean:</strong> \(\hat{\mu} = \frac{1}{m}\sum X_i(T)\)</li>
          <li><strong>Empirical Variance:</strong> sample variance of final values</li>
          <li><strong>Theoretical Distribution:</strong> displayed only for Wiener process</li>
        </ul>
      
        <h3>6. Interpretation & Practical Notes</h3>
        <ul class="info">
          <li>
            Smaller \(\Delta t\) improves accuracy but increases computation time.
          </li>
          <li>
            For linear drift/diffusion, closed-form solutions exist (e.g., Ornstein–Uhlenbeck, GBM),
            making this tool useful for verifying numerical accuracy.
          </li>
          <li>
            For nonlinear or custom coefficients, no analytical solution may exist — simulation becomes essential.
          </li>
          <li>
            The histogram can reveal skewness or multimodal behavior induced by state-dependent noise.
          </li>
          <li>
            Drift determines long-term direction; diffusion determines spread and volatility.
          </li>
        </ul>
      
        <p class="info">
          This simulator therefore acts both as a numerical verification tool and an exploratory playground
          for understanding stochastic dynamics.
        </p>
      </div>      

    <a class="back-button" href="../index.html">← Back</a>

    <footer>
      © 2025 Gabriele Paladini — All rights reserved.
    </footer>
  </div>

  <script>
    // Gaussian random generator (Box–Muller)
    function randn_bm() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function normalPdf(x, mu=0, sigma=1) {
      const s = sigma * Math.sqrt(2*Math.PI);
      const e = Math.exp(-0.5 * Math.pow((x-mu)/sigma,2));
      return e / s;
    }

    // ----- Wiener simulation -----
    function simulateWiener(T, n, m) {
      const dt = T / n;
      const timePoints = new Array(n+1);
      for (let i=0;i<=n;i++) timePoints[i] = i*dt;
      const paths = new Array(m);
      const finals = new Array(m);
      for (let run=0; run<m; run++){
        const X = new Array(n+1);
        let x = 0;
        X[0] = 0;
        for (let k=1;k<=n;k++){
          const dW = Math.sqrt(dt) * randn_bm();
          x = x + dW;
          X[k] = x;
        }
        paths[run] = X;
        finals[run] = x;
      }
      return {timePoints, paths, finals};
    }

    // ----- General SDE simulation (Euler–Maruyama) -----
    function simulateSDE(T, n, m, x0, driftFn, diffFn) {
      const dt = T / n;
      const timePoints = new Array(n+1);
      for (let i=0;i<=n;i++) timePoints[i] = i*dt;
      const paths = new Array(m);
      const finals = new Array(m);
      for (let run=0; run<m; run++){
        const X = new Array(n+1);
        let x = x0;
        X[0] = x0;
        for (let k=1;k<=n;k++){
          const t = timePoints[k-1];
          const dW = Math.sqrt(dt) * randn_bm();
          const a = driftFn(x, t);
          const b = diffFn(x, t);
          x = x + a * dt + b * dW;
          X[k] = x;
        }
        paths[run] = X;
        finals[run] = x;
      }
      return {timePoints, paths, finals};
    }

    // ----- Chart building -----
    let chartTraj = null;
    let chartHist = null;

    function buildTrajectoryDatasets(timePoints, paths, showMax) {
      const datasets = [];
      const palette = [
        'rgba(0,112,243,0.9)','rgba(0,112,243,0.7)','rgba(0,112,243,0.5)',
        'rgba(255,99,132,0.9)','rgba(255,159,64,0.9)','rgba(75,192,192,0.9)'
      ];
      const step = Math.max(1, Math.floor(paths.length / showMax));
      let colorIdx = 0;
      for (let i=0;i<paths.length;i+=step){
        const y = paths[i];
        datasets.push({
          label: `Run ${i+1}`,
          data: y.map((v, idx)=>({x: timePoints[idx], y: v})),
          borderColor: palette[colorIdx % palette.length],
          borderWidth: 1,
          pointRadius: 0,
          tension: 0,
          fill: false
        });
        colorIdx++;
        if (datasets.length >= showMax) break;
      }
      return datasets;
    }

    function buildHistogram(finals) {
      const min = Math.min(...finals);
      const max = Math.max(...finals);
      const nb = Math.min(60, Math.max(10, Math.floor(finals.length/5)));
      const width = (max - min) / nb || 1;

      const labels = [];
      const counts = [];
      const centers = [];
      for (let i=0;i<nb;i++){
        const c = min + (i+0.5)*width;
        labels.push(c.toFixed(3));
        centers.push(c);
        counts.push(0);
      }
      finals.forEach(v => {
        const idx = Math.min(nb-1, Math.floor((v - min)/width));
        counts[idx]++;
      });
      return {labels, counts, binCenters: centers, binWidth: width, min, max};
    }

    // ----- Plotting & statistics -----
    function renderCharts(sim, options) {
      const tp = sim.timePoints;
      const paths = sim.paths;
      const finals = sim.finals;
      const {T, procType, m, showMax} = options;

      // Trajectories
      const ctx1 = document.getElementById('chartTraj').getContext('2d');
      if (chartTraj) chartTraj.destroy();
      const trajDatasets = buildTrajectoryDatasets(tp, paths, showMax);
      chartTraj = new Chart(ctx1, {
        type: 'line',
        data: { datasets: trajDatasets },
        options: {
          parsing: false,
          plugins: {
            title: { display: true, text: `Sample trajectories (showing ${trajDatasets.length})` },
            legend: { display: false }
          },
          scales: {
            x: { type: 'linear', title: { display: true, text: 'time' }},
            y: { title: { display: true, text: 'X(t)' }}
          }
        }
      });

      // Histogram
      const hist = buildHistogram(finals);
      const ctx2 = document.getElementById('chartHist').getContext('2d');
      if (chartHist) chartHist.destroy();

      const labels = hist.labels;
      const empCounts = hist.counts;

      const datasets = [
        { type: 'bar', label: 'Empirical', data: empCounts, backgroundColor: 'rgba(255,99,132,0.7)', borderWidth:1 }
      ];

      // Add theoretical overlay for Wiener
      if (procType === 'wiener') {
        const mu = 0;
        const sigma = Math.sqrt(T);
        const pdfVals = hist.binCenters.map(c => normalPdf(c, mu, sigma));
        const pdfScaled = pdfVals.map(p => p * finals.length * hist.binWidth);
        datasets.push({
          type: 'line',
          label: `Theoretical density N(0,${T}) (scaled)`,
          data: pdfScaled,
          borderColor:'rgba(0,0,0,0.85)',
          borderWidth:2,
          fill:false,
          pointRadius:0,
          tension:0.2
        });
        document.getElementById('theoVal').textContent = `W_T ~ N(0, ${T})`;
      } else {
        document.getElementById('theoVal').textContent = `N/A (general SDE)`;
      }

      chartHist = new Chart(ctx2, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          plugins: { title: { display: true, text: `Histogram of X(T) over ${m} runs (T=${T})` } },
          scales: {
            x: { title: { display: true, text: 'value' } },
            y: { title: { display: true, text: 'counts' } }
          }
        }
      });

      // Stats
      const mean = finals.reduce((a,b)=>a+b,0) / finals.length;
      const varEmp = finals.reduce((s,v)=>s + Math.pow(v-mean,2), 0) / (finals.length - 1 || 1);
      document.getElementById('empMean').textContent = mean.toFixed(6);
      document.getElementById('empVar').textContent = varEmp.toFixed(6);
    }

    // ----- Build drift & diffusion -----
    function makeFunctionFromForm(form, mu, sigma, customStr) {
      if (form === 'const') return (x,t) => mu;
      if (form === 'linear') return (x,t) => mu * x;
      try {
        const fn = new Function('x','t','return '+customStr+';');
        const test = fn(0,0);
        if (typeof test !== 'number' || isNaN(test)) throw new Error("Function must return a number.");
        return fn;
      } catch (e) {
        alert("Error in custom function: " + e.message + "\nReverting to 0.");
        return (x,t) => 0;
      }
    }

    // ----- Run simulation button -----
    document.getElementById('btnRun').addEventListener('click', ()=>{
      const procType = document.getElementById('procType').value;
      const T = parseFloat(document.getElementById('inT').value);
      const n = parseInt(document.getElementById('inN').value);
      const m = parseInt(document.getElementById('inM').value);
      const showMax = parseInt(document.getElementById('inShow').value);

      if (!(T > 0 && n >= 1 && m >= 1)) {
        alert('Invalid parameters. Check T, n, m.');
        return;
      }

      if (procType === 'wiener') {
        const sim = simulateWiener(T, n, m);
        renderCharts(sim, {T, procType, m, showMax});
      } else {
        const x0 = parseFloat(document.getElementById('inX0').value);
        const driftForm = document.getElementById('driftForm').value;
        const diffForm  = document.getElementById('diffForm').value;
        const mu = parseFloat(document.getElementById('inMu').value);
        const sigma = parseFloat(document.getElementById('inSigma').value);
        const customDrift = document.getElementById('customDrift').value.trim();
        const customDiff  = document.getElementById('customDiff').value.trim();

        const driftFn = makeFunctionFromForm(driftForm, mu, sigma, customDrift);
        const diffFn  = makeFunctionFromForm(diffForm, sigma, mu, customDiff);

        const sim = simulateSDE(T, n, m, x0, driftFn, diffFn);
        renderCharts(sim, {T, procType, m, showMax});
      }
    });

    // ----- UI toggles -----
    const driftFormEl = document.getElementById('driftForm');
    const diffFormEl = document.getElementById('diffForm');

    function toggleCustomInputs() {
      document.getElementById('customDrift').style.display = (driftFormEl.value === 'custom') ? 'block' : 'none';
      document.getElementById('customDiff').style.display = (diffFormEl.value === 'custom') ? 'block' : 'none';
    }
    driftFormEl.addEventListener('change', toggleCustomInputs);
    diffFormEl.addEventListener('change', toggleCustomInputs);
    toggleCustomInputs();

    const procTypeEl = document.getElementById('procType');
    function toggleSDEcontrols() {
      const isSDE = procTypeEl.value === 'sde';
      [
        'inX0','driftForm','diffForm',
        'inMu','inSigma','customDrift','customDiff'
      ].forEach(id=>{
        const el = document.getElementById(id);
        if (el) el.disabled = !isSDE;
      });
    }
    procTypeEl.addEventListener('change', toggleSDEcontrols);
    toggleSDEcontrols();
  </script>
</body>
</html>
